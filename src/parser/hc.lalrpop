
use crate::{parser::ast::*, lexer::*};
use lalrpop_util::ParseError;

grammar(types: &mut Vec<Identifier>);

LiteralSignedInteger: i64 = "signed int";
LiteralUnsignedInteger: u64 = "unsigned int";
LiteralFloat: f64 = "float";
LiteralString: String = "string literal";
LiteralChars: Vec<u8> = "chars literal";

Identifier: Identifier = {
    "identifier" => Identifier::String(<>),
}
TypeIdentifier: Identifier = {
    "type identifier" => Identifier::Type(<>)
}

Value: Value = {
    Identifier => Value::Identifier(<>),
    LiteralSignedInteger => Value::Signed(<>),
    LiteralUnsignedInteger => Value::Unsigned(<>),
    LiteralFloat => Value::Float(<>),
    LiteralString => Value::String(<>),
    LiteralChars => Value::Chars(<>),
}

Expr: Expr = {
    #[precedence(level="1")]
    "(" <Expr> ")",
    Value => Expr::Value(<>),

    #[precedence(level="2")] #[assoc(side="left")]
    <Expr> "*" <Expr> => Expr::mul(<>),
    <Expr> "/" <Expr> => Expr::div(<>),

    #[precedence(level="3")] #[assoc(side="left")]
    <Expr> "+" <Expr> => Expr::add(<>),
    <Expr> "-" <Expr> => Expr::sub(<>),
}

Stmt: Statement = {
    <Expr> ";" => Statement::Expr(<>),
    <ty:TypeIdentifier> <star:"*"?> <ident:Identifier> "=" <value:Expr> ";" => 
        Statement::Assignment { ty: ty.maybe_pointer(star), ident, value },
    "class" <ident:TypeIdentifier> ";" => {
        types.push(ident.clone());
        Statement::Class(ident)
    },
}

Stmts: Vec<Statement> = {
    <mut this:Stmts> <next:Stmt> => {
        this.push(next);
        this
    },
    Stmt => vec![<>]
}

pub Default = Stmts;

extern {
    type Location = Location;
    type Error = LexicalError;
    enum Token {
        "=" => Token::OpAssign,
        "<<=" => Token::OpAShl,
        ">>=" => Token::OpAShr,
        "*=" => Token::OpAMul,
        "/=" => Token::OpADiv,
        "&=" => Token::OpABAnd,
        "|=" => Token::OpABOr,
        "^=" => Token::OpABXor,
        "+=" => Token::OpAAdd,
        "-=" => Token::OpASub,
        "||" => Token::OpOr,
        "^^" => Token::OpXor,
        "&&" => Token::OpAnd,
        "==" => Token::OpEq,
        "!=" => Token::OpNe,
        "<" => Token::OpLt,
        ">" => Token::OpGt,
        "<=" => Token::OpLe,
        ">=" => Token::OpGe,
        "+" => Token::OpAdd,
        "-" => Token::OpSub,
        "|" => Token::OpBOr,
        "^" => Token::OpBXor,
        "&" => Token::OpBAnd,
        "*" => Token::OpStar,
        "/" => Token::OpDiv,
        "%" => Token::OpMod,
        "!" => Token::OpNot,
        "*" => Token::OpStar,
        "&" => Token::OpRef,
        "`" => Token::OpPower,
        ">>" => Token::OpShr,
        "<<" => Token::OpShl,
        "++" => Token::OpAAdd,
        "--" => Token::OpASub,
        "signed int" => Token::Signed(<i64>),
        "unsigned int" => Token::Unsigned(<u64>),
        "float" => Token::Float(<f64>),
        "string literal" => Token::String(<String>),
        "chars literal" => Token::Chars(<Vec<u8>>),
        "identifier" => Token::Identifier(<String>),
        "type identifier" => Token::TypeIdent(<String>),
        "if" => Token::KwIf,
        "else" => Token::KwElse,
        "return" => Token::KwReturn,
        "class" => Token::KwClass,
        "define" => Token::KwDefine,
        "extern" => Token::KwExtern,
        "while" => Token::KwWhile,
        "public" => Token::KwPublic,
        "NULL" => Token::KwNull,
        "TRUE" => Token::KwTrue,
        "FALSE" => Token::KwFalse,
        "lastclass" => Token::KwLastClass,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        "{" => Token::OpenCurly,
        "}" => Token::CloseCurly,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "[" => Token::OpenSquare,
        "]" => Token::CloseSquare,
    }
}